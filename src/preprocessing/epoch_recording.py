"""
Script to take the files produced from the Suite2P preprocessing software and epoch the recording into trials.
INPUT: stim triggers in csv, Suite2P files (F.npy, Fneu.npy, iscell.npy)
OUTPUT: epoched_F.npy formatted as nCells x nTrials x nFrames array
        onsets.npy - list of frames where triggers occured
        raw_corrected_traces.npy - nNeurons x nFrames fluorescence traces (not epoched)
        cell_dictionary (.pkl) - dictionary of each cell ROI with epoched traces stored in {'traces' {freq {intensity {repetition}}}}
AUTHOR: Veronica Tarka, January 2022, veronica.tarka@mail.mcgill.ca
"""

import scipy.io as scio
import numpy as np
import os
import pickle
import json


# load what we need from the config file
with open(os.path.abspath(os.path.dirname(__file__)) +'/../../config.json','r') as f:
    config = json.load(f)

BASE_PATH = config['RecordingFolder'] # folder with all of the files generated by Suite2P for this recording (F.npy, iscell.npy, etc)
CSV_PATH = config['Triggers'] # name of CSV (assumed to be in the folder given in line above) with the trigger voltages over the recording
CONDITIONS_PATH = config['Conditions'] # name of the CSV (assumed to be in folder given two lines above) with the condition types of each trial (freq, intensity, etc)
OUTPUT_PATH = config['AnalysisFile'] # name of the file that all of the analysis is getting saved in (tuning, best frequency, etc)

STIMULUS_FRAMERATE = config['TriggerFR'] # framerate of the trigger file
TRIGGER_DELAY_IN_MS = config['TriggerDelay'] # delay between TDT sending a trigger and the stimulus actually happening
RECORDING_FRAMERATE = config['RecordingFR'] # framerate of the fluorescence recording
EPOCH_START_IN_MS = config['EpochStart'] # time to include before trial onset for each epoch
EPOCH_END_IN_MS = config['EpochEnd'] # time to include after trial onset for each epoch

STIM_FL_ERROR_ALLOWED = 10 # time in seconds to allow as the difference in length between the stim file and fluorescence trace

"""
Make sure the trigger file is the same length as the fluorescence trace
@param stimulus_len:  the number of frames in the trigger voltage trace
@param fluorescence_len: the number of frames in the fluorescence recordings (for one ROI)
@return T/F: T if the two recordings are the same length (+/- the allowed error)
"""
def are_valid_files(stimulus_len,fluorescence_len):
    # get the total length of the stimulus and the recording in seconds
    stimulus_length_in_sec = stimulus_len/STIMULUS_FRAMERATE # f * s/f = s
    fluorescence_length_in_sec = fluorescence_len/RECORDING_FRAMERATE

    # if one is short or longer by more than the allowed error, return False so we can respond accordingly
    if stimulus_length_in_sec < fluorescence_length_in_sec - STIM_FL_ERROR_ALLOWED \
         or stimulus_length_in_sec > fluorescence_length_in_sec + STIM_FL_ERROR_ALLOWED:
        return False
    else:
        return True

"""
Find the stimulus onsets from the trigger CSV and define as frames in the fluorescence recording
@param stimulus: 1D vector of the voltage trace of the stimulus triggers
@return onset_frames_at_recording_fr: a list of the frames in the fluo recording where the stim was presented
"""
def get_onset_frames(stimulus):
    # find the max voltage (this will be the value in the vector when the trigger was sent)
    max_voltage = max(stimulus, key=lambda x:x[1])
    max_voltage = max_voltage[1]

    onset_times = [] # empty list to append our onset frames into
    time_list_index = 0 # counter to keep track of our index in the onset_times list

    # for each frame in the stimulus file
    for stimulus_idx in range(len(stimulus)):
        (time,voltage) = stimulus[stimulus_idx] # unpack the voltage at that timepoint

        if voltage.round() == max_voltage.round(): # if the voltage was our trigger voltage
            if time_list_index == 0: # and if we're at the first index (so there's no previous index to compare with)
                trigger_time_in_sec = time/1000 + TRIGGER_DELAY_IN_MS/1000
                onset_times.append(trigger_time_in_sec) # add the time as an onset time in SECONDS
                time_list_index += 1

            # if we're not at index zero, we need to compare this voltage with the previous saved onset voltage
            # otherwise we save a bunch of voltages as separate triggers because they all match the max voltage
            # but we just want one timepoint per trigger
            elif time/1000 -  onset_times[time_list_index - 1] > 1: 
                trigger_time_in_sec = time/1000 + TRIGGER_DELAY_IN_MS/1000
                onset_times.append(trigger_time_in_sec) # want it in second not millisecond
                time_list_index += 1

    # get the onset times in terms of frames of our fluorescence trace
    onset_frames_at_recording_fr = np.multiply(onset_times,RECORDING_FRAMERATE) # s * f/s = f

    return onset_frames_at_recording_fr # a list of stimulus onsets in units of frames at recording framerate

"""
Divide the fluorescence traces into trials (from ROI x frames array to ROI x trials x frames array)
@param fl: the fluorescence traces given by Suite2P (nCells x nFrames)
@param onset_frames: a vector of frames (at the fluo recording framerate) where the stims began
@return epoched_traces: a nCells x nTrials x nFrames array where epoched_traces[0,0,:] would represent the fluo of the first trial of the first ROI
"""
def epoch_trace(fl,onset_frames):
    # first we'll find how many seconds are in each trial (based on the chosen epoch start and end)
    trial_length_in_ms = EPOCH_END_IN_MS - EPOCH_START_IN_MS # this gives us length in ms
    trial_length_in_sec = trial_length_in_ms/1000 # now we have it in seconds

    # converting to frames (at the frame rate of the 2P recording)
    trial_length_in_frames = int(trial_length_in_sec * RECORDING_FRAMERATE) # s * f/s = f

    # intitialize an array to store what we'll ultimately return
    # nCells x nTrials x nFramesPerTrials
    epoched_traces = np.zeros((len(fl),len(onset_frames),trial_length_in_frames))

    # start filling up this empty matrix
    # loop through each ROI
    for roi_idx in range(len(fl)):

        # and for each trial onset
        for trial_idx in range(len(onset_frames)):
            
            # get the trial starting frame and ending frame
            trial_starting_frame = np.round(onset_frames[trial_idx]) + (EPOCH_START_IN_MS/1000*RECORDING_FRAMERATE)
            trial_ending_frame = np.round(onset_frames[trial_idx]) + (EPOCH_END_IN_MS/1000*RECORDING_FRAMERATE)

            # grab this range of frames from the fl trace and store it in the epoched matrix
            trace = fl[roi_idx,int(trial_starting_frame):int(trial_ending_frame)]
            epoched_traces[roi_idx,trial_idx,:] = trace[:15]

    return epoched_traces

"""
Format the trials for a single ROI into a dictionary structure to store in the larger dictionary
@param traces: nTrials x nFrames array of the fluorescence for each trial for a SINGLE ROI
@param conditions: nTrial x 4 array detailing the frequency/intensity of each trial (see format_trials)
@return freq_dict: a dictionary formatted according to the internal comments (each unique frequency one key, intensities as sub dictionaries, repetitions as sub-subdictionaries)
"""
def format_trials(traces,conditions):

    # traces should be an nTrial x nFrame array of the dF/F over each trial
    # stim should be an nTrial x 4 array (info on this structure in the README.md)

    # this will return a dictionary that will be contained within this cell key in the big dictionary

    # format the dictionary so we get this structure:
    # freq_f{
    #   intensity_i{
    #       repetition{ 
    #           [x,x,x,x,...] }}}

    # use the frequencies we played as the keys of our dictionary (outermost dictionary)
    freq_dict = dict.fromkeys(np.unique(conditions[:,0]))

    # nest each intensity the frequencies were presented at inside our freq dictionary
    for freq in freq_dict:
        freq_dict[freq] = dict.fromkeys(np.unique(conditions[:,1]))

    # make empty dictionaries so we can index properly later
    for freq in freq_dict:
        for intensity in freq_dict[freq]:
            freq_dict[freq][intensity] = {}

    # make a temporary map so we can keep track of how many repetitions of this trial we've seen
    # just going to add together the frequency and intensity to index it
    # biggest element we'll need is max(frequency) + max(intensity)
    max_element = max(conditions[:,0]) + max(conditions[:,1]) + 10
    temp_map = [0] * max_element

    # for each trial
    for trial in range(len(conditions)):

        # trial's frequency
        f = conditions[trial,0]

        # trial's intensity
        i = conditions[trial,1]

        # access the map to see how many repetitions of the frequency and intensity we've already seen
        # this way we don't overwrite a trial with the same stimulus type
        num_rep = temp_map[f+i]+1
        temp_map[f+i] += 1

        # using the frequency and intensity to index our dictionary to store our trace
        freq_dict[f][i][num_rep] = traces[trial,:]

    return freq_dict

"""
Convert the epoched traces from an array to a dictionary
@param epoched_traces: nCells x nTrials x nFrames array as returned from epoch_trace
@param conditions: nTrials x 4 array where each row contains the frequency, intensity, trial delay, and stim length for a single trial 
@param iscell_logigical: nCells x 1 vector with 1 or 0 value to designate whether the ROI is a cell (1) or not (0)
@return dict_of_cells: dictionary where each cell is a key containing a subdictionary with the trials
"""
def format_all_cells(epoched_traces,conditions,iscell_logical):
    # find the label for each ROI by finding this indices where iscell_logical is 1
    ROI_indices = (iscell_logical[:,0] == 1).nonzero()
    ROI_indices = ROI_indices[0] # extracting the first part of the tuple
    cell_IDs = ROI_indices + 1 # add 1 so we don't have zero indexing

    # make a dictionary from this list
    dict_of_cells = dict.fromkeys(cell_IDs)

    # for each cell
    # format the dictionary so we get this structure:
    # cell_n{ 
    #    'traces'{
    #           freq_f{
    #               intensity_i{
    #                     repetition{
    #                           [x,x,x,x,...] }}}}}

    for cell_idx in range(len(cell_IDs)):
        dict_of_cells[cell_IDs[cell_idx]] = {'traces': format_trials(epoched_traces[cell_idx,:,:],conditions)}
    
    return dict_of_cells

def main():

    # load our files that were generated by Suite2P and the stim files
    stimulus = np.genfromtxt(BASE_PATH + CSV_PATH,delimiter=',',skip_header=True) # voltage values of the trigger software over the recording
    conditions_mat = scio.loadmat(BASE_PATH + CONDITIONS_PATH) # conditition type of each trial in chronological order (row 1 = trial 1)
    conditions = conditions_mat["stim_data"]
    fluorescence_trace = np.load(BASE_PATH + "F.npy",allow_pickle=True) # uncorrected trace of dF/F
    neuropil_trace = np.load(BASE_PATH + "Fneu.npy",allow_pickle=True) # estimation of background fluorescence
    iscell_logical = np.load(BASE_PATH + "iscell.npy",allow_pickle=True) # Suite2P's estimation of whether each ROI is a cell or not

    # make sure the stim file and flu traces are roughly the same length
    # if they aren't the same, we'll exit the code 
    if not are_valid_files(len(stimulus), len(fluorescence_trace[0])):
        raise ValueError("The lengths of stimulus file and the fluorescence traces are not the same. Exiting.")

    # get an array of all the stimulus onset times 
    # converted to be frames at the recording frame rate
    stimulus_onset_frames = get_onset_frames(stimulus)

    print(np.unique(conditions[:,0]))
    print(np.unique(conditions[:,1]))

    # account for the neuropil (background fluorescence)
    corrected_fluo = fluorescence_trace - 0.7*neuropil_trace
    
    # get fluorescence traces for the ROIs that are actually cells
    fluo_in_cells = corrected_fluo[np.where(iscell_logical[:,0]==1)[0],:]

    # epoch the traces so we just get the fluorescence during trials
    epoched_traces = epoch_trace(fluo_in_cells,stimulus_onset_frames)
    # epoched_traces_all = epoch_trace(corrected_fluo,stimulus_onset_frames)

    np.save(BASE_PATH+"raw_corrected_traces.npy",fluo_in_cells) # save the trace for each cell ROI 
    np.save(BASE_PATH+"epoched_traces.npy",epoched_traces) # save the trace for trial before it's formatted into a dictionary
    np.save(BASE_PATH+"onsets.npy",stimulus_onset_frames) # save the list of trigger frames (trial onsets)

    # collect some information about the stim to access later on if we want
    recording_info = dict()
    recording_info['frequencies'] = np.unique(conditions[:,0])
    recording_info['intensities'] = np.unique(conditions[:,1])
    recording_info['nRepeats'] = np.count_nonzero(np.logical_and(conditions[:,0]==recording_info['frequencies'][0],conditions[:,1] == recording_info['intensities'][0]))
    recording_info['nTrials'] = len(conditions)

    dictionary_of_cells = format_all_cells(epoched_traces,conditions,iscell_logical)

    # save to the provided output path
    with open(BASE_PATH+OUTPUT_PATH,'wb') as f:
        pickle.dump(dictionary_of_cells,f)

    # save the recording information 
    with open(BASE_PATH+"recording_info.pkl",'wb') as f:
        pickle.dump(recording_info,f)

if __name__=='__main__':
    main()